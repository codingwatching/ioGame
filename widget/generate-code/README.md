## 代码生成 - 介绍

[在线文档](https://www.yuque.com/iohao/game/irth38)



ioGame 是非常注重开发体验的，代码注释即文档、方法即交互接口的原则。



ioGame 具备一次编写到处对接的能力，从而做到了你们团队提升巨大的生产力可能性。一次编写指的是编写一次 java 业务代码，而到处对接则是指为不同的前端项目生成与服务器交互的代码。



ioGame 能为各种前端项目生成 action、广播、错误码 相关接口代码。这将意味着，你只需要编写一次业务代码，就可以同时与这些游戏引擎或现代化的前端框架交互。

---



## pom 导入

由于 generate-code 是单独的、按需选择的功能模块，使用时需要在 pom.xml 中引入

```xml
<!-- https://mvnrepository.com/artifact/com.iohao.game/generate-code -->
<dependency>
    <groupId>com.iohao.game</groupId>
    <artifactId>generate-code</artifactId>
    <version>${ioGame.version}</version>
</dependency>
```



## 使用示例

```java
public final class GenerateTest {
    ... 省略部分代码
    
    public static void main(String[] args) {
        // CHINA or US
        Locale.setDefault(Locale.CHINA);

        // Load the business framework of each gameLogicServer
        // 加载业务逻辑服
        SdkApplication.listLogic().forEach(BrokerClientStartup::createBarSkeleton);
        
        /*
         * GameExternalServer accessAuthentication
         * 游戏对外服访问权限，不生成权限控制的 action
         */
        SdkApplication.extractedAccess();
        DocumentAccessAuthentication reject = ExternalGlobalConfig.accessAuthenticationHook::reject;
        IoGameDocumentHelper.setDocumentAccessAuthentication(reject);
        
        /*
         * Generate actions, broadcasts, and error codes.
         * cn: 生成 action、广播、错误码
         */
        
        ...
       
        // Added an enumeration error code class to generate error code related information
        IoGameDocumentHelper.addErrorCodeClass(SdkGameCodeEnum.class);
        // Generate document；
        IoGameDocumentHelper.generateDocument();
        // Generate .proto
        generateProtoFile();
    }
    
    static void generateProtoFile() {
        /*
         * .proto generate
         * document https://www.yuque.com/iohao/game/vpe2t6
         */

        // By default, it will be generated in the target/proto directory
        // .proto 默认生成的目录为 target/proto

        // The package name to be scanned
        String packagePath = "com.iohao.example.sdk.data";
        GenerateFileKit.generate(packagePath);
    }
}

public final class SdkApplication {    
    static List<AbstractBrokerClientStartup> listLogic() {
        return List.of(
                new YourLogicServer()
        );
    }
    
    static void extractedAccess() {
        /*
         * Notice:
         *     Reject cmd: Routes that deny access to any player.
         *     These action methods will not be generated by the SDK.
         *
         *     将不会生成这些配置了 Rejection 的 action 方法。
         */
        accessAuthenticationHook.addRejectionCmd(1, 1);
    }
}
```





---

### Generate TypeScript

`generateCodeVue()`、`generateCodeHtml()`、`generateCocosCreator()` 都是通过 `TypeScriptDocumentGenerate` 类生成的。



使用 `TypeScriptDocumentGenerate` 类有两个需要注意的方法，分别是

1. `setPath`：当不做任何设置时，代码将会生成在 `target/code` 目录中，如果有需要可以指定生成的路径。
2. `setProtoImportPath`，这个是 .proto 的导入路径。因为 cocosCreator 比较特殊，需要使用 `db://` 开头的地址导入资源，而 Vue 使用相对路径即可导入。



举例说明 `setProtoImportPath`：即使 CocosCreator、Vue 使用相同的目录结构；CocosCreator 需要使用 `db://` 开头的地址导入 `common_pb.ts` 协议文件，而 Vue 使用相对路径即可。

```latex
.
├── code
│   ├── GameCode.ts
│   ├── Listener.ts
│   ├── MyAction.ts
│   └── SdkAction.ts
└── common_pb.ts
```



下面是关于生成 TypeScript 语言的代码，分别生成了 Vue、Html、CocosCreator 项目所需的交互代码。

```java
public final class GenerateTest {
    ... 省略部分代码
    public static void main(String[] args) {
        ... 省略部分代码

        /*
         * Generate actions, broadcasts, and error codes.
         * cn: 生成 action、广播、错误码
         */
        
        // About generating TypeScript code
        generateCodeVue();
        enerateCodeHtml();
        generateCocosCreator();
        
        ... 省略部分代码
    }
    
    private static void generateCodeVue() {
        var documentGenerate = new TypeScriptDocumentGenerate();

        // 设置代码生成所存放的路径，如果不做任何设置，将会生成在 target/code 目录中
        // By default, it will be generated in the target/code directory
        String path = "/Users/join/gitme/ioGame-sdk/ioGameSdkTsExampleVue/src/assets/gen/code";
        documentGenerate.setPath(path);

        // Your .proto path: Set the import path of common_pb in Vue.
        documentGenerate.setProtoImportPath("../common_pb");

        IoGameDocumentHelper.addDocumentGenerate(documentGenerate);
    }

    private static void generateCodeHtml() {
        var documentGenerate = new TypeScriptDocumentGenerate();

        // 设置代码生成所存放的路径，如果不做任何设置，将会生成在 target/code 目录中
        // By default, it will be generated in the   target/code directory
        String path = "/Users/join/gitme/ioGame-sdk/ioGameSdkTsExampleHtml/src/assets/gen/code";
        documentGenerate.setPath(path);

        // Your .proto path: Set the import path of common_pb in Vue.
        documentGenerate.setProtoImportPath("../common_pb");

        IoGameDocumentHelper.addDocumentGenerate(documentGenerate);
    }

    private static void generateCocosCreator() {
        var documentGenerate = new TypeScriptDocumentGenerate();

        // 设置代码生成所存放的路径，如果不做任何设置，将会生成在   target/code 目录中
        // By default, it will be generated in the   target/code directory
        String path = "/Users/join/gitme/ioGame-sdk/ioGameSdkTsExampleCocos/assets/scripts/gen/code";
        documentGenerate.setPath(path);

        // Your .proto path: Set the import path of common_pb in CocosCreator
        documentGenerate.setProtoImportPath("db://assets/scripts/gen/common_pb");

        IoGameDocumentHelper.addDocumentGenerate(documentGenerate);
    }
}
```



### Generate C#

`generateCodeCsharpUnity()`、`generateCodeCsharpGodot()` 都是通过 `CsharpDocumentGenerate` 类生成的。



使用 `CsharpDocumentGenerate` 类需要注意的方法有两个

1. `setPath`：当不做任何设置时，代码将会生成在 `target/code` 目录中，如果有需要可以指定生成的路径。
2. `setProtoImportPath`，这个是 .proto 的导入路径，使用 .proto 文件内 package 名。如果不做任何设置，默认值是 `using Pb.Common;`。



下面是关于生成 C# 语言的代码，分别生成了 Unity、Godot 项目所需的交互代码。

```java
public final class GenerateTest {
    ... 省略部分代码
    public static void main(String[] args) {
        ... 省略部分代码

        /*
         * Generate actions, broadcasts, and error codes.
         * cn: 生成 action、广播、错误码
         */
        
        // About generating C# code
        generateCodeCsharpUnity();
        generateCodeCsharpGodot();
        
        ... 省略部分代码
    }
    
    private static void generateCodeCsharpUnity() {
        var documentGenerate = new CsharpDocumentGenerate();
        // 设置代码生成所存放的路径，如果不做任何设置，将会生成在 target/code 目录中
        // By default, it will be generated in the target/code directory
        String path = "/Users/join/gitme/ioGame-sdk/ioGameSdkCsharpExampleUnity/Assets/Scripts/Gen/Code";
        documentGenerate.setPath(path);
        
        // Your .proto path: Set the import path of common_pb in C#
        // see target/proto/common.proto package
        // documentGenerate.setProtoImportPath("using Pb.Common;");

        IoGameDocumentHelper.addDocumentGenerate(documentGenerate);
    }

    private static void generateCodeCsharpGodot() {
        var documentGenerate = new CsharpDocumentGenerate();
        // 设置代码生成所存放的路径，如果不做任何设置，将会生成在 target/code 目录中
        // By default, it will be generated in the target/code directory
        String path = "/Users/join/gitme/ioGame-sdk/ioGameSdkCsharpExampleGodot/script/gen/code";
        documentGenerate.setPath(path);
        
        // Your .proto path: Set the import path of common_pb in C#
        // see target/proto/common.proto package
        // documentGenerate.setProtoImportPath("using Pb.Common;");

        IoGameDocumentHelper.addDocumentGenerate(documentGenerate);
    }
}
```



### 广播代码

TypeScript、C# 生成广播相关的代码文件统一命名为 `Listener`，如 `Listener.cs、Listener.ts`。Listener 文件中包含了服务器所有主动的广播动作，通常来说我们只需要在广播监听回调中编写自己的业务逻辑即可，如下



```csharp
// C#
Listener.ListenBulletBroadcast(result =>
{
    var bulletMessage = result.GetValue<BulletMessage>();
    result.Log(bulletMessage);
});

// 特殊方法，默认的监听动作，这是由 ioGame 生成的方法。
// 该方法为所有广播监听添加了打印的行为，目的是让开发者知道有哪些广播方法没有处理
Listener.Listener_ioGame();
```



```typescript
// Ts
Listener.listenBulletBroadcast(result => {
    const bullet = result.getValue(BulletMessageSchema);
    result.log(bullet);
})

// 特殊方法，默认的监听动作，这是由 ioGame 生成的方法。
// 该方法为所有广播监听添加了打印的行为，目的是让开发者知道有哪些广播方法没有处理
Listener.listener_ioGame();
```



### 错误码

错误码相关的代码文件统一命名为 `GameCode`，在触发错误时，服务器会将错误码放到 result responseStatus 字段中。



以下展示了两种编码风格关于错误的处理，这里使用的 C# 演示；Ts 的处理类似，这里就不演示了。

```csharp
public static async Task OnTestError()
{    
    var value = _testErrorValue++;
    Log("------- OnTestError ------");

    // code style: callback.
    SdkAction.OfTestError(value, result =>
    {
        result.Log(result.GetInt());
    }).OnError(result =>
    {
        // error
        result.Log(result.GetErrorInfo());
        // result.GetResponseStatus()
    });

    // code style: async await.
    var result = await SdkAction.OfAwaitTestError(value);
    // result.GetResponseStatus()
    if (result.Success())
        result.Log(result.GetInt());
    else
        result.Log(result.GetErrorInfo());
}
```



### 注意事项

默认情况下，生成的 action 交互代码的方法名使用的是 java action 的方法名。如果你的 java action 方法名有变动，则会影响客户端的代码。



为了避免此类情况，有两种方式

1. 不要更改已经发布的 action 方法名。
2. 给 action 添加 `DocumentMethod` 注解来固定方法名。ioGame 在生成对接代码时，会优先使用 `DocumentMethod` 注解的值。

```java
@ActionController(SdkCmd.cmd)
public final class SdkAction {    
    @ActionMethod(SdkCmd.noReturn)
    @DocumentMethod("noReturnMethod")
    public void noReturn(String name) {
        ... ...
    }
}
```



通常情况下，如果你没有经常更改 action 方法名的习惯，可以不需要使用 `DocumentMethod` 注解，因为这可以让你的代码保持简洁。但无论如何你都要记住，不要更改已经发布的方法名，因为这会让前端开发者产生不必要的小情绪。